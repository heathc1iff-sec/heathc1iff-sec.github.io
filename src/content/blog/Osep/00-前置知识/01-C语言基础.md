---
title: OSEP-前置知识-C语言基础
description: '00-前置知识 | 01-C语言基础'
pubDate: 2026-01-28
image: /image/fengmian/OSEP.png
categories:
  - Documentation
  - OffSec
tags:
  - PEN-300-OSEP
  - C Language
---
# C 语言基础 - 写给 Web 安全人员
## 为什么 Web 安全人员需要学 C 语言？
作为 Web 安全从业者，你可能习惯了 Python、JavaScript、PHP 这些高级语言。但在 OSEP 课程中，你会频繁接触到：

+ **Shellcode**：本质上是机器码，由 C/汇编编译而来
+ **Win32 API**：Windows 系统调用，C 语言风格的接口
+ **内存操作**：指针、内存分配、缓冲区操作
+ **DLL 开发**：需要用 C/C++ 编写

**你不需要成为 C 语言专家**，但需要能够：

1. 读懂 C 代码
2. 理解指针和内存概念
3. 理解 Win32 API 的调用方式

---

## 第一部分：C 语言基础语法
### 1.1 程序结构
```c
// 这是一个最简单的 C 程序
#include <stdio.h>    // 引入标准输入输出库，类似 Python 的 import

int main() {          // main 函数是程序入口，类似 Python 的 if __name__ == "__main__"
    printf("Hello, OSEP!\n");  // 打印输出，\n 是换行
    return 0;         // 返回 0 表示程序正常结束
}
```

![](/image/00-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/01-C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-1.png)

**与 Python 对比**：

```python
# Python 版本
print("Hello, OSEP!")
```

### 1.2 变量和数据类型
C 语言是**强类型语言**，必须声明变量类型：

```c
#include <stdio.h>
#include <windows.h>

int main(void) {
    // 基本数据类型
    int age = 20;           // 整型
    char letter = 'A';      // 字符
    float price = 19.99f;   // 单精度浮点数
    double pi = 3.14159265; // 双精度浮点数

    // Windows 特有类型
    DWORD processID = 1234;  // 无符号32位整数
    HANDLE hProcess = NULL;   // 句柄，用于引用系统对象
    LPVOID pBuffer = NULL;    // 指向任意类型的指针 (Long Pointer to VOID)
    BOOL success = TRUE;      // 布尔值 (实际是 int 类型; TRUE=1, FALSE=0)

    // 输出基本类型
    printf("age = %d\n", age);
    printf("letter = %c\n", letter);
    printf("price = %.2f\n", price);
    printf("pi = %f\n", pi);

    // 输出 Windows 特有类型
    printf("processID = %lu\n", (unsigned long)processID); // DWORD -> unsigned long
    printf("hProcess = %p\n", hProcess);                   // HANDLE 用 %p 输出指针
    printf("pBuffer = %p\n", pBuffer);                     // LPVOID 用 %p 输出指针
    printf("success = %d\n", success);                    // BOOL 实际是 int

    return 0;
}

```

![](/image/00-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/01-C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-2.png)

**重要概念 - 数据大小**：

| 类型 | 大小 | 范围 | OSEP 中的用途 |
| --- | --- | --- | --- |
| char | 1 字节 | -128 ~ 127 | 字符、shellcode 字节 |
| short | 2 字节 | -32768 ~ 32767 | 端口号 |
| int | 4 字节 | ±21 亿 | 一般整数 |
| long | 4/8 字节 | 取决于系统 | 地址、大小 |
| DWORD | 4 字节 | 0 ~ 42 亿 | 进程 ID、错误码 |
| SIZE_T | 4/8 字节 | 取决于系统 | 内存大小 |


### 1.3 字符串
C 语言没有原生字符串类型，字符串是**字符数组**：

```c
#include<stdio.h>
int main() {
    char str1[] = "Hello_str1";
    char str2[9] = "1234567890abcdefj";   // 指定大小，剩余填充 \0
    char str3[9] = "12345";   // 指定大小，剩余填充 \0
    char *str4 = "Hello_str4";  // 指针指向字符串常量

    // 字符串实际存储（以 "Hello" 为例）
    // 内存: | H | e | l | l | o | \0 |
    //       字符串以 \0 (NULL) 结尾，这很重要！
    printf("%s\n",str1);
	printf("%s\n",str2);
	printf("%s\n",str1);
	printf("%s\n",str3);
	printf("%s\n",str4);
}
```

![](/image/00-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/01-C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-3.png)

>  你看到 `"123456789Hello_str1"` 是 **printf 读取越界** 的结果，不是变量被覆盖
>
> ### 为什么 printf("%s", str2) 会打印 `Hello_str1`？
> 1. `printf("%s", str2)` 会**从 **`**str2**`** 起始地址开始打印**
> 2. 它会一直打印，直到遇到 `\0`（字符串结束符）
> 3. 你给 `str2` 的空间只有 9 个字节，字符串 `"1234567890abcdefj"` 太长，**最后的 **`**\0**`** 不在 str2 数组内**
> 4. 于是 printf 继续沿着内存向下读取，读到栈上 **下一个变量 str1 的内容**，打印出来
>
> ✅ 关键点：
>
> + **内存被打印出来，不等于 str1 被覆盖**
> + 你自己检查 str1 时它的值是 `"Hello_str1"`，说明 str1 内存没有被写入，**只是 printf 继续读了它的地址**
>

```c
高地址
-------------------
str3[8]    '\0'
str3[7]    '\0'
str3[6]    '\0'
str3[5]    '\0'
str3[4]    '5'
str3[3]    '4'
str3[2]    '3'
str3[1]    '2'
str3[0]    '1'
-------------------
str2[8]    '9'
str2[7]    '8'
str2[6]    '7'
str2[5]    '6'
str2[4]    '5'
str2[3]    '4'
str2[2]    '3'
str2[1]    '2'
str2[0]    '1'
-------------------
str1[9]    '\0'
str1[8]    '1'
str1[7]    'r'
str1[6]    's'
str1[5]    '_' 
str1[4]    'o'
str1[3]    'l'
str1[2]    'l'
str1[1]    'e'
str1[0]    'H'
-------------------
低地址
```

>  栈上分配的内存是连续的：  
>

```c
高地址
-------------------
str2[8]  <- 9 个字节
str1[9]  <- 10 个字节
低地址
```

 你可以把内存想象成一条连续的字符带子：  

```c
|1|2|3|4|5|6|7|8|9|H|e|l|l|o|_|s|t|r|1|\0|...
```

> + `str2` 指向第一个 `1`
> + printf `%s` 从 `1` 开始读，直到遇到 `\0`
>

**Web 安全类比**：

+ C 字符串的 `\0` 结尾类似于 HTTP 协议中的 `\r\n\r\n` 分隔符
+ 很多漏洞（如缓冲区溢出）就是因为没有正确处理 `\0`

---

## 第二部分：指针 - 最重要的概念
### 2.1 什么是指针？
**指针就是内存地址**。

想象内存是一排储物柜：

+ 每个柜子有一个**编号**（地址）
+ 每个柜子里存放**东西**（值）
+ **指针**就是记录柜子编号的纸条

```c
#include <stdio.h>

int main(void) {
    // 定义一个普通整数变量 number，并赋值为 42
    int number = 42;

    // 定义一个指针变量 ptr，类型为 int*（指向 int 的指针）
    // 并把 number 的地址赋给 ptr
    int *ptr = &number;

    // 假设 number 存储在地址 0x5FFE54
    // 那么 ptr 的值就是 0x5FFE54（ptr 指向 number 的地址）

    // 打印 number 的值
    printf("number value: %d\n", number);  // 输出: 42

    // 打印 number 的地址
    printf("number address: %p\n", &number);  // 输出: 0x5FFE54

    // 打印 ptr 的值（即它指向的地址）
    printf("ptr value: %p\n", ptr);  // 输出: 0x5FFE54

    // 打印 ptr 指向地址的值（解引用）
    // *ptr = 读取 ptr 指向地址的值，也就是 number 的值
    printf("value pointed by ptr: %d\n", *ptr);  // 输出: 42

    *ptr = 10;
    printf("number new value:%d\n",number);
    return 0; // 程序结束
}

```

![](/image/00-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/01-C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-4.png)

> 指针声明
>
> + `int *ptr = &number;`
> + `int *` 在声明中表示 **这是一个指针int变量**
> + `&number` 是 `number` 的地址
> + 所以 ptr **保存了 number 的地址**
>
> 指针使用
>

> + `*ptr`
> + 在使用时 `*` 表示 **解引用**，访问指针指向地址的值
> + `*ptr` 等价于 `number`
>

### 2.2 指针操作符
| 操作符 | 名称 | 作用 | 示例 |
| --- | --- | --- | --- |
| `&` | 取地址 | 获取变量的内存地址 | `&number` |
| `*` | 解引用 | 获取指针指向的值 | `*ptr` |


```c
int x = 10;
int *p = &x;    // p 指向 x

*p = 20;        // 通过指针修改 x 的值
printf("%d\n", x);  // 输出: 20
```

### 2.3 为什么 OSEP 需要理解指针？
**指针 = 一个“装着地址的变量”**

```plain
一个变量，里面存的是：某块内存的起始位置
```

在 OSEP 中，你会频繁遇到这些场景：

```c
// 场景 1: 分配内存存放 shellcode
// LPVOID 指向任意类型的指针 (Long Pointer to VOID)
LPVOID shellcodeAddr = VirtualAlloc(  
    NULL,                    // 让系统决定地址
    shellcodeSize,           // 分配大小
    MEM_COMMIT,              // 提交内存
    PAGE_EXECUTE_READWRITE   // 可读可写可执行
);
// shellcodeAddr 现在是一个指针，指向分配的内存

// 场景 2: 复制 shellcode 到分配的内存
memcpy(shellcodeAddr, shellcode, shellcodeSize);
// 将 shellcode 数组的内容复制到 shellcodeAddr 指向的位置

// 场景 3: 执行 shellcode
((void(*)())shellcodeAddr)();
// 将地址转换为函数指针并调用
```

#### 场景 1：VirtualAlloc 到底干了什么
```plain
LPVOID shellcodeAddr = VirtualAlloc(...);    
```

这一步**只干了一件事**：

**向操作系统要了一块内存，并把“这块内存的起始地址”交给你**

假设系统返回的是这个地址（举例）：

```plain
0x000001A3F0000000
```

那么现在内存状态是：

```plain
变量 shellcodeAddr
┌─────────────────────────┐
│ 0x000001A3F0000000       │  ← 这是一个地址
└─────────────────────────┘
```

而**真正的内存**在别的地方：

```plain
地址 0x000001A3F0000000:
┌────┬────┬────┬────┬────┬────┬────┐
│ ?? │ ?? │ ?? │ ?? │ ?? │ ?? │ ?? │  ← 一大片可执行内存
└────┴────┴────┴────┴────┴────┴────┘
```

👉 **此时：**

+ `shellcodeAddr` 是个指针
+ 它**不是 shellcode**
+ 它只是“告诉你 shellcode 将来会放在哪”

---

#### 场景 2：memcpy 为什么能“写进去”
```plain
memcpy(shellcodeAddr, shellcode, shellcodeSize);
```

重点来了。

##### memcpy 的真实含义（翻译成人话）
```plain
从 shellcode 的地址开始
把 shellcodeSize 个字节
一个一个复制
到 shellcodeAddr 指向的内存里
```

也就是说：

+ `shellcodeAddr`**不是值**
+ 它被当成：**“目标内存的起始地址”**

复制完成后，内存变成这样：

```plain
地址 0x000001A3F0000000:
┌────┬────┬────┬────┬────┬────┬────┐
│ 90 │ 90 │ CC │ 48 │ 31 │ C0 │ C3 │ ← shellcode 字节
└────┴────┴────┴────┴────┴────┴────┘
```

👉 **此时：**

+ shellcode **真的存在内存里了**
+ shellcodeAddr 只是“指向它的路标”

---

#### 最关键的一步：为什么它“能执行”
```plain
((void(*)())shellcodeAddr)();
```

这句看起来吓人，但我们拆掉外壳：

##### 1️⃣ `(void(*)())` 是什么？
**“这是一个函数指针类型”**

意思是：  
“一个地址，这个地址上放着一段可执行代码”

不是调用  
不是执行  
只是**告诉编译器怎么看这个地址**

---

##### 2️⃣ `(void(*)())shellcodeAddr`
这一步只是说：

“我不再把 shellcodeAddr 当普通地址  
我现在把它当成 **函数入口地址**”

---

##### 3️⃣ 最后的 `()`
这一步才是真正发生的事：

**CPU：跳到 shellcodeAddr 这个地址开始执行指令**

就等价于：

```plain
RIP = shellcodeAddr
开始执行内存里的机器码
```

### 2.4 指针与数组
数组名本质上是指向第一个元素的指针：

```c
unsigned char shellcode[] = "\xfc\x48\x83\xe4\xf0...";

// 以下两种写法等价
unsigned char first_byte = shellcode[0];
unsigned char first_byte = *shellcode;

// 以下两种写法也等价
unsigned char third_byte = shellcode[2];
unsigned char third_byte = *(shellcode + 2);
```

#### 关键真相：数组名 ≈ 指针（在表达式中）
在 C 里：

```plain
shellcode
```

在**表达式中**会自动退化为：

```plain
&shellcode[0]
```

也就是：  
👉 **指向第一个字节的指针**

所以：

```plain
*shellcode
```

等价于：

```plain
*(&shellcode[0])  // 解引用第 0 个元素
```

自然就是：

```plain
shellcode[0]
```

---

####  shellcode[i] 的“真实含义”（非常重要）
很多人以为：

```plain
shellcode[2]
```

是“数组访问”

❌ **不是**

它只是语法糖，本质是：

```plain
*(shellcode + 2)
```

而 `shellcode + 2` 的意思是：

```plain
地址 + 2 × sizeof(unsigned char)
```

因为 `unsigned char` 的大小是 1 字节：

```plain
shellcode + 2 = 起始地址 + 2 字节
```

---

#### 用内存画出来（不抽象）
假设内存是这样的：

```plain
地址        内容
0x1000      FC
0x1001      48
0x1002      83
0x1003      E4
0x1004      F0
```

```plain
shellcode == 0x1000
```

那么：

| 写法 | 实际含义 | 读的是 |
| --- | --- | --- |
| `*shellcode` | `*(0x1000)` | FC |
| `shellcode[0]` | `*(0x1000 + 0)` | FC |
| `shellcode[2]` | `*(0x1000 + 2)` | 83 |
| `*(shellcode + 2)` | `*(0x1002)` | 83 |


---

## 第三部分：函数
### 3.1 函数定义
```c
// 函数格式: 返回类型 函数名(参数类型 参数名, ...) { 函数体 }

int add(int a, int b) {
    return a + b;
}

// 无返回值用 void
void printMessage(char *message) {
    printf("%s\n", message);
}

// 调用函数
int result = add(3, 5);      // result = 8
printMessage("Hello!");       // 打印 Hello!
```

### 3.2 Win32 API 函数风格
Win32 API 有特定的命名和参数风格：

```c
// 典型的 Win32 API 函数
// HANDLE 句柄，用于引用系统对象
// DWORD 无符号32位整数
HANDLE CreateFileA(
    LPCSTR lpFileName,           // 文件名 (LP = Long Pointer, C = Const, STR = String)
    DWORD dwDesiredAccess,       // 访问权限 (dw = DWORD)
    DWORD dwShareMode,           // 共享模式
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,  // 安全属性
    DWORD dwCreationDisposition, // 创建方式
    DWORD dwFlagsAndAttributes,  // 标志和属性
    HANDLE hTemplateFile         // 模板文件句柄 (h = Handle)
);
```

**命名约定**：

+ `lp` = Long Pointer（指针）
+ `dw` = DWORD（32位无符号整数） 
+ `h` = Handle（句柄）
+ `sz` = String Zero-terminated（以 \0 结尾的字符串）
+ `cb` = Count of Bytes（字节数）
+ `A` 后缀 = ANSI 版本
+ `W` 后缀 = Wide/Unicode 版本

---

**HANDLE ≈ 操作系统给你的“编号/钥匙”，用来间接操作内核对象**  
👉 **不是指针**  
👉 **不能解引用**  
👉 **只对当前进程有意义**

---

#### 1️⃣ Windows 里真正存在的东西是什么？
当你调用：

```plain
HANDLE h = CreateFileA("test.txt", ...);
```

**真正发生的事情是：**

1. Windows 内核里创建了一个 **内核对象**
    - 文件对象（File Object）
    - 在 **内核地址空间**
2. 你这个进程：
    - **绝对访问不到内核内存**
3. 内核说：

“我不能把真实地址给你，那你随便玩就能蓝屏了”

所以它做了👇

---

#### 2️⃣ 句柄的本质（重点）
##### 👉 HANDLE 本质是：
```plain
进程私有的索引 / 票据 / 句柄值
```

通常是个 `void*` 或 `int` 大小的值，比如：

```plain
0x000000000000012C
```

但这个值：

❌ 不是文件的内存地址  
❌ 不是 FILE*  
❌ 不是你能读写的东西

---

#### 3️⃣ 用“句柄表”来理解（非常关键）
##### 每个进程都有一个：
```plain
Handle Table（句柄表）
```

可以想成这样 👇

```plain
你的进程
┌──────────────┐
│ Handle Table │
├──────────────┤
│ 0x0004  → 内核文件对象 A │
│ 0x0008  → 内核文件对象 B │
│ 0x0010  → Socket 对象     │
│ 0x012C  → test.txt 文件对象 │  ← 你的 HANDLE
└──────────────┘
```

你拿到的：

```plain
HANDLE h = 0x012C;
```

其实只是：

“请帮我用 **编号 0x012C** 操作那个内核对象”

---

#### 4️⃣ 所以 HANDLE 为什么不是指针？
##### 对比一下 👇
###### 指针（你熟的）
```plain
int x = 10;
int *p = &x;
printf("%d", *p);  // OK
```

你能：

+ 解引用
+ 算地址
+ 越界（UB）

---

###### HANDLE（完全不行）
```plain
HANDLE h;
printf("%d", *h);   // ❌ 直接崩
```

因为：

+ `h` 只是一个 **编号**
+ 内核通过这个编号查表
+ **你永远看不到真实对象**

---

#### 5️⃣ CreateFileA 每个参数到底在干嘛（人话版）
```plain
HANDLE h = CreateFileA(
    "test.txt",           // 你要操作哪个文件
    GENERIC_READ,         // 我要读
    FILE_SHARE_READ,      // 别人也能读
    NULL,                 // 默认安全
    OPEN_EXISTING,        // 必须存在
    FILE_ATTRIBUTE_NORMAL,// 普通文件
    NULL                  // 不用模板
);
```

成功后：

+ Windows 内核：
    - 创建 / 打开文件对象
+ 返回：
    - 一个 **HANDLE**

之后你只能这样用它：

```plain
ReadFile(h, buffer, size, &read, NULL);
WriteFile(h, data, len, &written, NULL);
CloseHandle(h);
```

👉 **所有操作都通过 HANDLE**

## 第四部分：内存管理
### 4.1 栈 vs 堆
```plain
内存布局（简化版）
┌─────────────────┐ 高地址
│      栈 Stack    │ ← 局部变量、函数参数
│        ↓        │    自动分配和释放
├─────────────────┤
│        ↑        │
│      堆 Heap     │ ← 动态分配的内存
│                 │    需要手动管理
├─────────────────┤
│   数据段 Data    │ ← 全局变量、静态变量
├─────────────────┤
│   代码段 Code    │ ← 程序代码
└─────────────────┘ 低地址
```

### 4.2 动态内存分配
```c
// C 标准库方式
char *buffer = (char *)malloc(1024);  // 分配 1024 字节
if (buffer == NULL) {
    // 分配失败处理
}
// 使用 buffer...
free(buffer);  // 释放内存

// Windows API 方式（OSEP 中更常用）
LPVOID buffer = VirtualAlloc(
    NULL,                    // 系统决定地址
    1024,                    // 大小
    MEM_COMMIT | MEM_RESERVE,// 保留并提交
    PAGE_READWRITE           // 可读可写
);
// 使用 buffer...
VirtualFree(buffer, 0, MEM_RELEASE);  // 释放
```

#### 一、先解释 `VirtualFree(buffer, 0, MEM_RELEASE);`
**这行代码在字节层面干了什么？**

```plain
VirtualFree(buffer, 0, MEM_RELEASE);
```

##### 参数逐个解释（非常具体）
###### 1️⃣ `buffer`
+ **VirtualAlloc 返回的起始虚拟地址**
+ 必须是：
    - VirtualAlloc 分配的
    - 页对齐的地址

---

###### 2️⃣ `0`（这个 0 很多人不懂）
当 `dwFreeType == MEM_RELEASE` 时：

`**dwSize**`** 必须为 0**

意思是：

“不是释放一部分，是把整个那一段地址空间都还给 OS”

---

###### 3️⃣ `MEM_RELEASE`
它的真实含义是：

**撤销虚拟地址映射**

在 OS 内部发生的事是：

+ 页表项删除
+ 虚拟地址 → 物理页 的映射断开
+ 地址空间标记为“未占用”

📌 **不是清零内存，是“这块地址不存在了”**

---

##### 用一句很底层的话说
`VirtualFree(..., MEM_RELEASE)`  
= “这段地址以后再访问就是非法的了”

---

#### 二、再回答你最关键的问题：malloc 的 buffer 到底是什么？
---

##### 1️⃣ `char *buffer = malloc(1024);` 到底意味着什么？
```plain
char *buffer = (char *)malloc(1024);
```

拆开来看：

###### malloc 做的事：
+ 向堆要：
    - 一段 **连续虚拟内存**
    - **至少 1024 字节**
+ 返回：
    - **第一个字节的地址**

所以：

```plain
buffer == 某个虚拟地址
```

比如：

```plain
buffer = 0x000001F4A0C00000
```

---

##### 2️⃣ buffer 不是“数组”，是“地址”
这句话很重要：

**buffer 只是一个地址值**

你写：

```plain
buffer[0] = 'A';
```

CPU 真正执行的是：

```plain
*(buffer + 0) = 'A';
```

也就是：

```plain
*(0x...0000) = 0x41
```

👉 **就是往内存地址写数据**

---

##### 3️⃣ 那为什么不会炸？
因为：

+ 这段地址：
    - 属于你的进程
    - 已经被 OS 映射
    - 有写权限

所以这是 **合法的内存写操作**

---

##### 4️⃣ 如果你写第 1025 个字节会发生什么？
```plain
buffer[1024] = 'X';
```

理论上：

+ ❌ **未定义行为**
+ 实际上：
    - 可能没事
    - 可能覆盖别的堆块
    - 可能崩

👉 **C 不帮你检查边界**

---

#### 三、(char *) 和 char * 到底有啥区别？
你问的是个**经典但容易被讲烂的问题**，我给你最干净的版本。

---

##### 结论先给：
`**char ***`** 和 **`**(char *)**`** 完全不是一个层面的东西**

---

##### 1️⃣ `char *` —— 类型声明
```plain
char *buffer;
```

意思是：

buffer 是一个“指向 char 的指针”

这是 **类型**

---

##### 2️⃣ `(char *)` —— 类型转换（cast）
```plain
(char *)malloc(1024)
```

意思是：

“我告诉编译器：  
把 malloc 返回的那个地址，当作 char* 来看”

---

##### 3️⃣ 在 C 里，这个 cast 要不要？
###### 在 C 语言 中：
```plain
char *buffer = malloc(1024);  // ✅ 正确
```

+ malloc 返回 `void *`
+ `void *` → `char *`**自动转换**

👉 `(char *)`**是多余的**

---

###### 在 C++ 中：
```plain
char *buffer = malloc(1024);  // ❌ 编译错误
```

必须写：

```plain
char *buffer = (char *)malloc(1024);
```

---

#### **VirtualAlloc和malloc**一句话先定性（先记住）
**malloc 是“语言级内存管理”  
****VirtualAlloc 是“操作系统级内存管理”**

两者**完全不是一个层级的东西**。

---

#### 先给你一张“层级图”（非常重要）
```plain
你的代码
  |
  |  malloc / free        ← C 运行时（CRT）
  |  ↓
  |  Heap 管理器
  |  ↓
  |  VirtualAlloc / VirtualFree
  |  ↓
Windows 内核（内存管理器）
  |
  |  页表 / 物理内存
```

👉 **malloc 最终也是靠 VirtualAlloc 活着的**

---

#### 一、malloc 到底在干嘛？
```plain
char *buffer = malloc(1024);
```

##### malloc 的本质是：
**从“进程堆（heap）”里切一块给你**

特点：

+ 内存来自 **进程堆**
+ 由 **C 运行时（CRT）** 管理
+ 可能：
    - 合并
    - 拆分
    - 缓存
+ **你不知道真实地址怎么来的**

##### malloc 的优点
+ 简单
+ 跨平台
+ 适合普通程序

##### malloc 的限制（OSEP 里很致命）
+ ❌ 不能指定页面权限
+ ❌ 不能直接申请 RWX
+ ❌ 不关心页对齐
+ ❌ 不适合 shellcode / 注入

---

#### 二、VirtualAlloc 在干嘛？（重点）
```plain
LPVOID buffer = VirtualAlloc(
    NULL,
    1024,
    MEM_COMMIT | MEM_RESERVE,
    PAGE_READWRITE
);
```

##### VirtualAlloc 的本质是：
**直接向操作系统申请“虚拟内存页”**

你在和 **Windows 内核内存管理器** 说话。

---

#### 三、VirtualAlloc 的每个参数到底意味着什么（不抽象）
##### 1️⃣ 地址（NULL）
```plain
NULL
```

意思是：

“你帮我选一个合适的虚拟地址”

你也可以自己指定（高级玩法）。

---

##### 2️⃣ 大小（1024）
⚠️ 重点：

**真正分配的是“页”**

+ Windows 页大小：**4 KB**
+ 你要 1024，实际给你 **4096**
+ 剩下的你看不见，但存在

---

##### 3️⃣ MEM_RESERVE vs MEM_COMMIT（非常关键）
这是很多人卡住的地方。

###### MEM_RESERVE
+ 只占地址空间
+ 不分配物理内存
+ 不可访问

###### MEM_COMMIT
+ 真正分配物理页
+ 可访问

###### 常见组合
```plain
MEM_RESERVE | MEM_COMMIT
```

意思是：

“占坑 + 立刻给内存”

---

##### 4️⃣ PAGE_READWRITE（权限）
这是 **malloc 做不到的事**。

你可以指定：

+ `PAGE_READWRITE`
+ `PAGE_EXECUTE_READWRITE` ← 💥
+ `PAGE_EXECUTE_READ`

👉 **OSEP / Shellcode / 注入的核心**

---

#### 四、为什么 OSEP 里更常用 VirtualAlloc？
一句话：

**因为你需要“控制内存的权限和行为”**

##### OSEP 场景举例（不讲 exploit）
+ Shellcode 需要：
    - 可执行内存
+ 注入需要：
    - 指定地址
+ 绕过 DEP：
    - 明确设置执行权限
+ ROP / Loader：
    - 页对齐

👉 malloc **做不到**

---

#### 五、free vs VirtualFree 的本质区别
##### free(buffer)
+ 只是：
    - 把内存还给 **堆管理器**
+ **不一定立刻还给 OS**
+ 地址空间可能继续占着

---

##### VirtualFree(buffer, 0, MEM_RELEASE)
+ 直接告诉 OS：

“这段虚拟地址空间我不要了”

+ 页表清空
+ 物理页回收
+ 地址空间释放

---

#### 六、你现在这段代码，其实在对比两种“哲学”
| malloc | VirtualAlloc |
| --- | --- |
| 语言级 | OS 级 |
| 抽象 | 精确 |
| 安全 | 强控制 |
| 方便 | 强大 |
| 普通程序 | 底层 / 安全 / OSEP |


---

#### 七、把它和你之前学的东西串起来（关键）
你已经学过：

+ 指针只是地址
+ 用户态不能乱碰内核
+ 内存是连续的
+ printf 会越界读
+ shellcode 是字节流

👉 **VirtualAlloc 是你“合法获得一块可控内存”的方式**

---

## 一句你现在能真正理解的话（终极）
**malloc 是“我需要点内存”  
****VirtualAlloc 是“我需要一页、在这里、用这个权限”**

### 4.3 内存保护属性
这在 OSEP 中非常重要：

| 属性 | 值 | 含义 | 用途 |
| --- | --- | --- | --- |
| PAGE_READONLY | 0x02 | 只读 | 保护数据 |
| PAGE_READWRITE | 0x04 | 可读可写 | 一般数据 |
| PAGE_EXECUTE | 0x10 | 可执行 | 代码段 |
| PAGE_EXECUTE_READ | 0x20 | 可执行可读 | 正常代码 |
| PAGE_EXECUTE_READWRITE | 0x40 | 可读可写可执行 | **Shellcode 执行** |


```c
// 分配可执行内存（用于 shellcode）
LPVOID execMem = VirtualAlloc(
    NULL,
    shellcodeSize,
    MEM_COMMIT,
    PAGE_EXECUTE_READWRITE  // 关键：必须可执行
);
```

---

## 第五部分：结构体
### 5.1 结构体基础
结构体用于组合多个相关的数据：

```c
// 定义结构体
struct Person {
    char name[50];
    int age;
    float height;
};

// 使用结构体
struct Person john;
strcpy(john.name, "John");
john.age = 30;
john.height = 1.75;

// 或者使用指针
struct Person *pJohn = &john;
pJohn->age = 31;  // 指针用 -> 访问成员
```

### 5.2 Windows 中的结构体
OSEP 中会遇到很多 Windows 结构体：

```c
// 进程信息结构体
typedef struct _PROCESS_INFORMATION {
    HANDLE hProcess;      // 进程句柄
    HANDLE hThread;       // 主线程句柄
    DWORD  dwProcessId;   // 进程 ID
    DWORD  dwThreadId;    // 线程 ID
} PROCESS_INFORMATION;

// 启动信息结构体
typedef struct _STARTUPINFOA {
    DWORD  cb;            // 结构体大小
    LPSTR  lpReserved;
    LPSTR  lpDesktop;
    LPSTR  lpTitle;
    // ... 更多字段
} STARTUPINFOA;

// 使用示例
STARTUPINFOA si;
PROCESS_INFORMATION pi;

ZeroMemory(&si, sizeof(si));  // 清零结构体
si.cb = sizeof(si);           // 设置大小

CreateProcessA(
    "notepad.exe",  // 程序路径
    NULL,           // 命令行参数
    NULL, NULL,     // 安全属性
    FALSE,          // 继承句柄
    0,              // 创建标志
    NULL,           // 环境变量
    NULL,           // 当前目录
    &si,            // 启动信息
    &pi             // 进程信息（输出）
);
```

#### `si` 本身是什么？
+ `si`**不是指针**
+ `si` 是一个 **结构体变量**
+ 表示的是：  
👉 **这一整块内存**

---

#### `&si` 是什么？
```plain
&si
```

意思是：

**“这块结构体的起始地址”**

#### 为什么 `CreateProcessA` 要 `&si`？
**我们来看函数原型（你已经贴出来了）：**

```plain
BOOL CreateProcessA(
    ...
    LPSTARTUPINFOA lpStartupInfo,
    LPPROCESS_INFORMATION lpProcessInformation
);
```

##### 展开类型别名：
```plain
typedef STARTUPINFOA* LPSTARTUPINFOA;
typedef PROCESS_INFORMATION* LPPROCESS_INFORMATION;
```

**也就是说：**

**Windows API 要的是“指向结构体的指针”**

---

## 第六部分：实战代码解读
### 6.1 简单的 Shellcode 执行器
```c
#include <windows.h>
#include <stdio.h>

// Shellcode（这里用 MessageBox 作为示例）
unsigned char shellcode[] =
    "\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50"
    "\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52"
    // ... 省略
    ;

int main() {
    // 步骤 1: 分配可执行内存
    LPVOID mem = VirtualAlloc(
        NULL,                          // 让系统选择地址
        sizeof(shellcode),             // 分配大小
        MEM_COMMIT | MEM_RESERVE,      // 保留并提交内存
        PAGE_EXECUTE_READWRITE         // 可读可写可执行
    );

    if (mem == NULL) {
        printf("VirtualAlloc failed: %d\n", GetLastError());
        return 1;
    }

    // 步骤 2: 复制 shellcode 到分配的内存
    memcpy(mem, shellcode, sizeof(shellcode));

    // 步骤 3: 创建线程执行 shellcode
    HANDLE hThread = CreateThread(
        NULL,                          // 默认安全属性
        0,                             // 默认栈大小
        (LPTHREAD_START_ROUTINE)mem,   // 线程函数地址（shellcode）
        NULL,                          // 传递给线程的参数
        0,                             // 立即运行
        NULL                           // 不需要线程 ID
    );

    // 步骤 4: 等待线程结束
    WaitForSingleObject(hThread, INFINITE);

    return 0;
}
```

**代码解析**：

1. **VirtualAlloc**: 在进程的虚拟地址空间中分配内存
    - 类比 Web：就像在服务器上申请一块存储空间
2. **memcpy**: 将 shellcode 复制到分配的内存
    - 类比 Web：就像上传文件到服务器
3. **CreateThread**: 创建新线程执行代码
    - 类比 Web：就像启动一个新的后台任务
4. **WaitForSingleObject**: 等待线程完成
    - 类比 Web：就像等待异步请求返回

---

## 章节测试
### 选择题
1. 在 C 语言中，`int *p` 声明的是什么？
    - A) 一个整数变量
    - B) 一个指向整数的指针
    - C) 一个整数数组
    - D) 一个整数常量
2. `&variable` 操作符的作用是？
    - A) 获取变量的值
    - B) 获取变量的地址
    - C) 声明一个引用
    - D) 进行位与运算
3. 在 Windows 中，`DWORD` 类型的大小是？
    - A) 1 字节
    - B) 2 字节
    - C) 4 字节
    - D) 8 字节
4. 执行 shellcode 时，内存需要什么保护属性？
    - A) PAGE_READONLY
    - B) PAGE_READWRITE
    - C) PAGE_EXECUTE_READWRITE
    - D) PAGE_NOACCESS
5. `LPVOID` 类型表示什么？
    - A) 长整型
    - B) 指向 void 的指针
    - C) 字符串
    - D) 布尔值

### 代码阅读题
阅读以下代码，回答问题：

```c
int x = 100;
int *p = &x;
*p = 200;
int **pp = &p;
**pp = 300;
```

6. 执行完所有语句后，`x` 的值是多少？
7. `pp` 是什么类型的变量？

### 实践题
8. 编写一个 C 程序，使用 `VirtualAlloc` 分配 1024 字节的内存，然后用 `VirtualFree` 释放它。

---

## 答案
1. B - `int *p` 声明一个指向整数的指针
2. B - `&` 是取地址操作符
3. C - DWORD 是 32 位（4 字节）无符号整数
4. C - 执行代码需要 EXECUTE 权限
5. B - LPVOID = Long Pointer to VOID
6. 300 - 通过二级指针修改了 x 的值
7. 指向指针的指针（二级指针），类型是 `int **`

---

## 下一步
掌握了 C 语言基础后，继续学习 [02-汇编语言入门.md](aa6974cc7172281b2e04be11eea1dfde)，了解 shellcode 的底层原理。

